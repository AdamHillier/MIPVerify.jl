<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic Usage · MIPVerify.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MIPVerify.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../tutorials.html">Tutorials</a></li><li><span class="toctext">Finding Adversarial Examples</span><ul><li class="current"><a class="toctext" href="basic_usage.html">Basic Usage</a><ul class="internal"><li><a class="toctext" href="#Index-1">Index</a></li><li><a class="toctext" href="#Public-Interface-1">Public Interface</a></li></ul></li><li><a class="toctext" href="batch_processing.html">Batch Processing</a></li></ul></li><li><span class="toctext">Working with Neural Net Parameters</span><ul><li><a class="toctext" href="../net_components/overview.html">Overview</a></li><li><a class="toctext" href="../net_components/layers.html">Layers</a></li><li><a class="toctext" href="../net_components/nets.html">Networks</a></li><li><a class="toctext" href="../net_components/core_ops.html">Core Operations</a></li></ul></li><li><span class="toctext">Importing</span><ul><li><a class="toctext" href="../utils/import_weights.html">Importing Parameter Values</a></li><li><a class="toctext" href="../utils/import_datasets.html">Importing External Datasets</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Finding Adversarial Examples</li><li><a href="basic_usage.html">Basic Usage</a></li></ul><a class="edit-page" href="https://github.com/vtjeng/MIPVerify.jl/blob/master/docs/src/finding_adversarial_examples/basic_usage.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Basic Usage</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Basic-Usage-1" href="#Basic-Usage-1">Basic Usage</a></h1><p><a href="basic_usage.html#MIPVerify.find_adversarial_example-Tuple{MIPVerify.NeuralNet,Array{#s25,N} where N where #s25&lt;:Real,Union{Array{#s200,1} where #s200&lt;:Integer, Integer},MathProgBase.SolverInterface.AbstractMathProgSolver}"><code>find_adversarial_example</code></a> is the core function that you will be calling to  find adversarial examples. To avoid spending time verifying the wrong network, we suggest that you check that the network gets reasonable performance on the test set using <a href="basic_usage.html#MIPVerify.frac_correct-Tuple{MIPVerify.NeuralNet,MIPVerify.LabelledDataset,Int64}"><code>frac_correct</code></a>.</p><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="basic_usage.html#MIPVerify.find_adversarial_example-Tuple{MIPVerify.NeuralNet,Array{#s25,N} where N where #s25&lt;:Real,Union{Array{#s200,1} where #s200&lt;:Integer, Integer},MathProgBase.SolverInterface.AbstractMathProgSolver}"><code>MIPVerify.find_adversarial_example</code></a></li><li><a href="basic_usage.html#MIPVerify.frac_correct-Tuple{MIPVerify.NeuralNet,MIPVerify.LabelledDataset,Int64}"><code>MIPVerify.frac_correct</code></a></li></ul><h2><a class="nav-anchor" id="Public-Interface-1" href="#Public-Interface-1">Public Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.find_adversarial_example-Tuple{MIPVerify.NeuralNet,Array{#s25,N} where N where #s25&lt;:Real,Union{Array{#s200,1} where #s200&lt;:Integer, Integer},MathProgBase.SolverInterface.AbstractMathProgSolver}" href="#MIPVerify.find_adversarial_example-Tuple{MIPVerify.NeuralNet,Array{#s25,N} where N where #s25&lt;:Real,Union{Array{#s200,1} where #s200&lt;:Integer, Integer},MathProgBase.SolverInterface.AbstractMathProgSolver}"><code>MIPVerify.find_adversarial_example</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">find_adversarial_example(nn, input, target_selection, main_solver; pp, norm_order, tolerance, rebuild, invert_target_selection, tightening_algorithm, tightening_solver, cache_model, solve_if_predicted_in_targeted)
</code></pre><p>Finds the perturbed image closest to <code>input</code> such that the network described by <code>nn</code> classifies the perturbed image in one of the categories identified by the  indexes in <code>target_selection</code>.</p><p><code>main_solver</code> specifies the solver used.</p><p><em>Formal Definition</em>: If there are a total of <code>n</code> categories, the output vector <code>y</code> has  length <code>n</code>. We guarantee that <code>y[j] - y[i] ≥ tolerance</code> for some <code>j ∈ target_selection</code>  and for all <code>i ∉ target_selection</code>.</p><p><strong>Named Arguments:</strong></p><ul><li><p><code>pp::PerturbationFamily</code>: Defaults to <code>UnrestrictedPerturbationFamily()</code>. Determines   the family of perturbations over which we are searching for adversarial examples.</p></li><li><p><code>norm_order::Real</code>: Defaults to <code>1</code>. Determines the distance norm used to determine the    distance from the perturbed image to the original. Supported options are <code>1</code>, <code>Inf</code>    and <code>2</code> (if the <code>main_solver</code> used can solve MIQPs.)</p></li><li><p><code>tolerance::Real</code>: Defaults to <code>0.0</code>. See formal definition above.</p></li><li><p><code>rebuild::Bool</code>: Defaults to <code>false</code>. If <code>true</code>, rebuilds model by determining upper and lower   bounds on input to each non-linear unit even if a cached model exists.</p></li><li><p><code>invert_target_selection::Bool</code>: Defaults to <code>false</code>. If <code>true</code>, sets <code>target_selection</code> to    be its complement.</p></li><li><p><code>tightening_algorithm::MIPVerify.TighteningAlgorithm</code>: Defaults to <code>mip</code>. Determines how we determine the upper and lower   bounds on input to each nonlinear unit. Allowed options are <code>interval_arithmetic</code>, <code>lp</code>, <code>mip</code>.  (1) <code>interval_arithmetic</code> looks at the bounds on the output to the previous layer.  (2) <code>lp</code> solves an <code>lp</code> corresponding to the <code>mip</code> formulation, but with any integer constraints relaxed.  (3) <code>mip</code> solves the full <code>mip</code> formulation.</p></li><li><p><code>tightening_solver</code>: Defaults to the same type of solver as   the <code>main_solver</code>, with a time limit of 20s per solver and output suppressed. Used only   if the <code>tightening_algorithm</code> is <code>lp</code> or <code>mip</code>.</p></li><li><p><code>cache_model</code>: Defaults to <code>true</code>. If <code>true</code>, saves model generated (but does <em>not</em> remove)   existing cached model if <code>false</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/dcc5053b612ce8a662e725e5c117bddf42e8b6f3/src/MIPVerify.jl#L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.frac_correct-Tuple{MIPVerify.NeuralNet,MIPVerify.LabelledDataset,Int64}" href="#MIPVerify.frac_correct-Tuple{MIPVerify.NeuralNet,MIPVerify.LabelledDataset,Int64}"><code>MIPVerify.frac_correct</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">frac_correct(nn, dataset, num_samples)
</code></pre><p>Returns the fraction of items the neural network correctly classifies of the first <code>num_samples</code> of the provided <code>dataset</code>. If there are fewer than <code>num_samples</code> items, we use all of the available samples.</p><p><strong>Named Arguments:</strong></p><ul><li><p><code>nn::NeuralNet</code>: The parameters of the neural network.</p></li><li><p><code>dataset::LabelledDataset</code>:</p></li><li><p><code>num_samples::Int</code>: Number of samples to use.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/dcc5053b612ce8a662e725e5c117bddf42e8b6f3/src/MIPVerify.jl#L133">source</a></section><footer><hr/><a class="previous" href="../tutorials.html"><span class="direction">Previous</span><span class="title">Tutorials</span></a><a class="next" href="batch_processing.html"><span class="direction">Next</span><span class="title">Batch Processing</span></a></footer></article></body></html>
